---
#
# Environment validation and initialization
#
- name: Gather information about execution environment
  block:
    - name: Verify execution environment configuration
      ansible.builtin.stat:
        path: "{{ playbook_dir }}/environments/{{ current_env }}/execution-environment.yml"
      register: ee_config_file

    - name: Set environment status facts
      ansible.builtin.set_fact:
        ee_config_exists: "{{ ee_config_file.stat.exists | default(false) }}"
        ee_config_path: "{{ playbook_dir }}/environments/{{ current_env }}/execution-environment.yml"
  
    - name: Announce environment processing
      ansible.builtin.debug:
        msg: |
          ===============================================
          Starting build for environment: {{ current_env }}
          Config path: {{ ee_config_path }}
          Config exists: {{ 'Yes' if ee_config_exists else 'No' }}
          ===============================================
  
    - name: Validate environment configuration
      ansible.builtin.assert:
        that: ee_config_exists
        fail_msg: |
          Cannot build execution environment for {{ current_env }}
          Missing configuration file: {{ ee_config_path }}
          Please create this file before continuing.
        success_msg: "Environment configuration validated successfully for {{ current_env }}"
  rescue:
    - name: Report environment validation failure
      ansible.builtin.fail:
        msg: |
          Environment initialization failed for {{ current_env }}
          This could be due to missing files or permission issues.
          Error details: {{ ansible_failed_result | default('Unknown error') }}
      when: ansible_failed_task is defined

#
# Directory and file preparation
#
- name: Create required directories
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    mode: '0755'
  loop:
    - "{{ playbook_dir }}/environments/{{ current_env }}"
    - "{{ work_dir }}/context"
    - "{{ work_dir }}/_build"

- name: Check for required files
  ansible.builtin.stat:
    path: "{{ playbook_dir }}/environments/{{ current_env }}/{{ item }}"
  loop:
    - execution-environment.yml
    - requirements.txt
    - requirements.yml
    - bindep.txt
  register: file_checks

- name: Create empty requirements.txt if it doesn't exist
  ansible.builtin.file:
    path: "{{ playbook_dir }}/environments/{{ current_env }}/requirements.txt"
    state: touch
    mode: '0644'
  when: not file_checks.results[0].stat.exists

- name: Create default requirements.yml if it doesn't exist
  ansible.builtin.copy:
    content: |
      ---
      collections:
        - name: ansible.utils
          version: ">=2.10.0"
        - name: ansible.posix
          version: ">=1.5.4"
        - name: community.general
          version: ">=7.0.0"
    dest: "{{ playbook_dir }}/environments/{{ current_env }}/requirements.yml"
    mode: '0644'
  when: not file_checks.results[1].stat.exists

- name: Create default bindep.txt if it doesn't exist
  ansible.builtin.copy:
    content: |
      # System dependencies for Python packages
      gcc [platform:rpm]
      make [platform:rpm]
      libxml2-devel [platform:rpm]
      openssl-devel [platform:rpm]
      python3-devel [platform:rpm]
      rpm-build [platform:rpm]
      # Kerberos dependencies
      krb5-devel [platform:rpm]
      krb5-libs [platform:rpm]
      krb5-workstation [platform:rpm]
    dest: "{{ playbook_dir }}/environments/{{ current_env }}/bindep.txt"
    mode: '0644'
  when: not file_checks.results[2].stat.exists

#
# Fix execution-environment.yml issues
#
- name: Check for property issues in execution-environment.yml
  ansible.builtin.shell: |
    grep -l '^[[:space:]]*{{ item.key }}[[:space:]]*:' "{{ playbook_dir }}/environments/{{ current_env }}/execution-environment.yml" || true
  loop:
    - { key: "prepend", name: "prepend" }
    - { key: "append", name: "append" }
  register: property_checks
  changed_when: false
  loop_control:
    label: "{{ item.name }}"
  args:
    executable: /bin/bash

- name: Fix invalid 'prepend' property
  ansible.builtin.replace:
    path: "{{ playbook_dir }}/environments/{{ current_env }}/execution-environment.yml"
    regexp: '^(\s*)prepend(\s*):(\s*.*)$'
    replace: '\1prepend_builder\2:\3'
  when: >
    property_checks.results | selectattr('item.key', 'eq', 'prepend') | list | length > 0 and
    property_checks.results | selectattr('item.key', 'eq', 'prepend') | first | regex_search('prepend')
  register: prepend_fixed

- name: Fix invalid 'append' property
  ansible.builtin.replace:
    path: "{{ playbook_dir }}/environments/{{ current_env }}/execution-environment.yml"
    regexp: '^(\s*)append(\s*):(\s*.*)$'
    replace: '\1append_builder\2:\3'
  when: >
    property_checks.results | selectattr('item.key', 'eq', 'append') | list | length > 0 and
    property_checks.results | selectattr('item.key', 'eq', 'append') | first | regex_search('append')
  register: append_fixed

- name: Display property fix status
  ansible.builtin.debug:
    msg: "Fixed invalid properties in execution-environment.yml for {{ current_env }}: prepend → prepend_builder, append → append_builder"
    verbosity: 3
  when: prepend_fixed.changed or append_fixed.changed

- name: Fix python package references in execution-environment.yml for RHEL 9
  ansible.builtin.replace:
    path: "{{ playbook_dir }}/environments/{{ current_env }}/execution-environment.yml"
    regexp: 'python39-(pip|devel)'
    replace: 'python3-\1'
  when: "'rhel9' in current_env"
  register: ee_python_fixed

- name: Fix python package references in bindep.txt for RHEL 9
  ansible.builtin.replace:
    path: "{{ playbook_dir }}/environments/{{ current_env }}/bindep.txt"
    regexp: '^python39-devel \[platform:rpm\]$'
    replace: 'python3-devel [platform:rpm]'
  when: "'rhel9' in current_env and (playbook_dir ~ '/environments/' ~ current_env ~ '/bindep.txt') is file"
  register: bindep_python_fixed

#
# Fix requirements.yml issues
#
- name: Check for issues in requirements.yml
  ansible.builtin.shell: |
    grep -l '{{ item.pattern }}' "{{ playbook_dir }}/environments/{{ current_env }}/requirements.yml" || true
  loop:
    - { pattern: 'ansible\.builtin', name: 'ansible.builtin' }
    - { pattern: 'infra\.ansible', name: 'infra.ansible' }
  register: req_checks
  changed_when: false
  loop_control:
    label: "{{ item.name }}"
  args:
    executable: /bin/bash

- name: Fix ansible.builtin reference in requirements.yml
  ansible.builtin.replace:
    path: "{{ playbook_dir }}/environments/{{ current_env }}/requirements.yml"
    regexp: '(\s+)- name: ansible.builtin(\s+.*)?'
    replace: '# The following line was removed as ansible.builtin is part of ansible-core and cannot be installed separately'
  when: >
    req_checks.results | selectattr('item.name', 'eq', 'ansible.builtin') | list | length > 0 and
    req_checks.results | selectattr('item.name', 'eq', 'ansible.builtin') | first | regex_search('ansible\.builtin')
  register: builtin_fixed

- name: Fix infra.ansible reference in requirements.yml
  ansible.builtin.replace:
    path: "{{ playbook_dir }}/environments/{{ current_env }}/requirements.yml"
    regexp: '(\s+)- name: infra\.ansible(\s+.*)?'
    replace: '\1- name: infra.ee_utilities\n\1- name: infra.aap_utilities'
  when: >
    req_checks.results | selectattr('item.name', 'eq', 'infra.ansible') | list | length > 0 and
    req_checks.results | selectattr('item.name', 'eq', 'infra.ansible') | first | regex_search('infra\.ansible')
  register: infra_ansible_fixed

- name: Display collection fixes
  ansible.builtin.debug:
    msg: "Fixed {{ item.name }} reference in requirements.yml for {{ current_env }}"
    verbosity: 3
  loop:
    - { name: "ansible.builtin", changed: "{{ builtin_fixed.changed | default(false) }}" }
    - { name: "infra.ansible", changed: "{{ infra_ansible_fixed.changed | default(false) }}" }
  when: item.changed | bool

#
# Clean up existing resources
#
- name: Clean up execution environment resources
  block:
    - name: Find containers related to this build
      ansible.builtin.shell: |
        podman ps -a --filter "name={{ current_env }}" --format '{{ "{{" }}.ID{{ "}}" }}' | tr '\n' ' '
      register: container_ids
      changed_when: false
      args:
        executable: /bin/bash

    - name: Set container facts
      ansible.builtin.set_fact:
        containers_to_remove: "{{ container_ids.stdout.split() }}"

    - name: Report cleanup plan
      ansible.builtin.debug:
        msg: "Found {{ containers_to_remove | length }} container(s) related to {{ current_env }} to remove"
        verbosity: 3

    - name: Remove containers
      ansible.builtin.command:
        cmd: "podman rm -f {{ containers_to_remove | join(' ') }}"
      when: containers_to_remove | length > 0
      changed_when: true
      
    - name: Remove build context directory
      ansible.builtin.file:
        path: "{{ work_dir }}/context"
        state: absent

    - name: Find all existing tagged images
      ansible.builtin.shell: |
        podman images --format '{% raw %}{{ .Repository }}:{{ .Tag }}{% endraw %}' | grep -v "<none>:<none>" | sort
      register: all_tagged_images
      changed_when: false
      args:
        executable: /bin/bash

    - name: Build initial protected images list
      ansible.builtin.set_fact:
        protected_images: "{{ all_tagged_images.stdout_lines | default([]) }}"
      
    - name: Check if current image exists with tag
      ansible.builtin.command:
        cmd: "podman image exists {{ current_env }}"
      register: image_check
      changed_when: false
      failed_when: false

    # Ensure current_env is in protected list if it exists
    - name: Add current environment image to protected list if not already there
      ansible.builtin.set_fact:
        protected_images: "{{ protected_images | default([]) + [current_env] | unique }}"
      when: image_check.rc == 0
      
    - name: Display protected images
      ansible.builtin.debug:
        msg: 
          - "Protected images that won't be deleted unless selected from menu:"
          - "{{ protected_images }}"
        verbosity: 2
  rescue:
    - name: Report cleanup failure
      ansible.builtin.debug:
        msg: "Warning: Resource cleanup encountered an issue. Continuing with build anyway."

#
# Build container image
#
- name: Ensure ansible-builder is available
  ansible.builtin.command:
    cmd: which ansible-builder
  register: builder_check
  changed_when: false
  failed_when: false

- name: Check if rebuild was specifically requested
  ansible.builtin.set_fact:
    force_rebuild: "{{ force_rebuild | default(false) | bool or (selected_environments is defined and current_env in selected_environments) }}"

- name: Skip build for existing images unless forced
  ansible.builtin.debug:
    msg: "Image {{ current_env }} already exists. Skipping build. Use menu option to force rebuild."
  when: 
    - image_check is defined
    - image_check.rc == 0
    - not force_rebuild

- name: Pre-build cleanup for Podman storage issues
  ansible.builtin.shell: |
    # Report info on the specific image we're building
    echo "Preparing to build image: {{ current_env }}"
    
    # Try to remove the image if it exists
    podman image exists {{ current_env }} && podman rmi -f {{ current_env }} || true
    
    # Clear builder cache for this specific image
    rm -rf /var/lib/containers/storage/overlay-layers/*/rhel9*
    rm -rf /var/lib/containers/storage/overlay-images/*/rhel9*
    
    # Send a message to tmux monitor if it exists
    if tmux has-session -t podman-monitor 2>/dev/null; then
      tmux send-keys -t podman-monitor:0.0 "echo 'Cleaning storage for {{ current_env }} build...'" C-m
    fi
  changed_when: true
  ignore_errors: true
  register: pre_build_cleanup
  when: "'rhel9' in current_env"

- name: Build container image
  ansible.builtin.command:
    cmd: >-
      ansible-builder build 
      --tag {{ current_env }} 
      --container-runtime podman 
      --verbosity 3
      --prune-images
      --context {{ work_dir }}/context
      --build-arg AH_TOKEN={{ automation_hub_token | default('') }}
      --builder-image registry.access.redhat.com/ubi9/buildah:latest
      -f {{ environment_dir }}/execution-environment.yml
  environment:
    BUILDAH_FORMAT: docker
    STORAGE_DRIVER: vfs
    BUILDAH_ISOLATION: chroot
    PODMAN_IGNORE_CGROUPSV1_WARNING: "1"
  register: build_result
  failed_when: false
  changed_when: build_result.rc == 0

- name: Display build result summary
  ansible.builtin.debug:
    msg: "{{ current_env }} build {{ 'succeeded' if build_output.rc == 0 else 'failed' }}"

- name: Show detailed build output
  ansible.builtin.debug:
    msg: |
      Build command output (last 20 lines):
      {{ (build_output.stdout_lines | default([]))[-20:] | join('\n') }}
      
      Build command errors (if any):
      {{ build_output.stderr_lines | default([]) | join('\n') }}
  when: 
    - build_output is defined
    - (build_output.stdout_lines | default([]) | length > 0) or 
      (build_output.stderr_lines | default([]) | length > 0)
  failed_when: false

- name: Verify image was built successfully
  ansible.builtin.command:
    cmd: "podman image exists {{ current_env }}"
  register: image_exists
  changed_when: false
  failed_when: false

- name: Report build verification
  ansible.builtin.debug:
    msg: "{{ 'Image ' + current_env + ' exists in local registry.' if image_exists.rc == 0 else 'WARNING: Image ' + current_env + ' was not found after build!' }}"

- name: Notify if infra.ansible was fixed
  ansible.builtin.debug:
    msg: "Fixed infra.ansible reference in requirements.yml for {{ current_env }}"
  when: infra_ansible_fixed.changed | default(false)

- name: Update protected images in cleanup.yml 
  ansible.builtin.blockinfile:
    path: "{{ playbook_dir }}/tasks/cleanup.yml"
    block: |
      # This list is automatically generated from existing images
      # Images will NOT be deleted unless specifically selected from menu
      protected_images:
      {% for image in protected_images | default([]) %}
        - "{{ image }}"
      {% endfor %}
    marker: "# {mark} ANSIBLE MANAGED PROTECTED IMAGES"
    create: yes
    mode: '0644'
  when: 
    - protected_images is defined 
    - protected_images | length > 0
